# ⭐변수
## 변수란 무엇인가? 왜 필요한가?

: 컴퓨터는 CPU를 이용해 연산하고, 메모리를 사용해 데이터를 기억 한다. 이때 기억한 주소값(값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간의 주소값)을 식별하기 위해 붙인 이름을 의미

**값의 위치를 가리키는 상징적인 이름**

1. 메모리
- 셀의 집합체로, 셀 1개는 1Byte (8bit)이다.
- 각 셀은 고유한 메모리 주소, 즉 공간을 가진다.
- **각 셀에 저장한 데이터를 재사용하기 위해 주소값을 가리키는 변수를 활용하는 것**

```
💡 주소값을 직접 사용하면 안되는 이유는 무엇일까?
=> 1) 실수로 운영체제가 사용하고 있는 값을 변경하게 되면, 시스템을 멈추게하는 치명적인 오류가 생길 수 있다.
=> 2) 값이 저장될 메모리 주소는 코드가 실행될 때마다 메모리의 상황에 따라 변경된다.
      따라서, 동일한 코드를 실행하더라도 값이 저장되는 주소값이 계속해서 변경되기 때문에 재사용의 의미를 잃는다.
```

## 식별자

: 어떤 값을 구별해서 식별할 수 있는 고유한 이름 (변수, 함수, 객체 등의 이름을 모두 포함)

- 값이 저장되어 있는 메모리 주소와 매핑 관계를 맺으며, 이 매핑 정보(result가 0x0669F913와 매핑이 되어있다는 정보)도 메모리에 저장되어야 한다.

| 메모리 주소 | 식별자 | 메모리 공간 |
| --- | --- | --- |
| 0x0669F913 | result | 30 |
- 메모리 주소를 기억 (값 아님)한 메모리 주소에 붙인 이름
- [네이밍 규칙](#-식별자-네이밍-규칙)을 준수해야 함
- 선언에 의해 자바스크립트 엔진에 식별자의 존재를 알려야 사용할 수 있음

>❗선언하지 않고 사용하면 무슨 에러가 발생할까!? <br />
>     **ReferenceError (참조 에러)** <br />
> : 선언하지 않은 식별자에 접근했을 때 발생하는 에러로, 자바스크립트 엔진이 등록된 식별자를 찾을 수 없을 때 발생하는 에러이다.`

## 변수 선언
: 값을 저장하기 위한 메모리 공간을 확보하고, 변수 이름과 확보된 공간의 주소를 연결해서 값을 저장할 수 있게 준비하는 것 (변수를 생성하는 것)

- 선언에서 확보된 공간은 확보가 해제되기 전까지는 다른 식별자가 그 공간을 사용할 수 없다. (값을 저장할 수 있도록 공간을 보호하는 것)

### 선언 키워드
1. **var키워드**
: ES6가 도입되기 이전까지는 var 키워드가 유일한 선언문이었지만, ES6부터는 let과 const 키워드가 등장하여 var 선언의 문제점을 보완하고 있다.
2. let & const
: ES6가 도입되면서 등장한 키워드로, 이 키워드에 대해서는 이후의 장에서 따로 다루도록 하겠다.
```
💡Var 키워드를 더이상 사용하지 않는 이유
1. 블록 레벨 스코프를 지원하지 않고, 함수 레벨 스코프를 지원한다.
-> 예상치 못한 범위에서 변수가 유효하게 되어, 의도치 않은 변수의 공유 및 오버라이드를 초래할 수 있다. (재정의하여 사용하는 것이 가능하기 때문)
-> if문이나 for문 코드 블로 내에서 선언된 변수도 외부에서 접근이 가능하고, 이로 인해 외부에 의해 제어문 안의 변수값이 변경되어 버그가 발생할 수 있다.
```

** 이후 장에서 다루면 link 예정 **

### 선언 과정
: var 키워드는 뒤에 오는 변수 이름으로 새로운 변수를 선언할 것을 지시하는 키워드이다.

```
var score ; // 변수 선언 (변수 선언문)
```

- 이렇게 선언했을 때, 변수로 선언된 메모리 공간에 아무것도 없을 것이라고 생각하겠지만 자바스크립트 엔진은 이 공간에 우선 `undefined`를 할당한다.
=> 암묵적 할당이 이루어지는 것인데, 이는 **자바스크립트의 독특한 특징**이다.

위의 과정이 변수 선언의 2단계이다.

- **선언 단계** : 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.
- **초기화 단계** : 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 `undefined`를 할당해 초기화한다.
- * 일반적으로 초기화란 변수가 선언된 이후 최초로 값을 할당하는 것을 말하는데, var 키워드로 선언한 변수는 아무런 값을 할당하지 않아도 `undefined`란 값을 가진다. **
- * 만약 초기화 단계를 거치지 않으면, 확보된 메모리 공간에는 이전에 사용했던 쓰레기 값이 남아있을 수 있다. var 키워드는 값을 할당하지 않아도 초기화를 수행하므로 이러한 위험에서부터 안전하다 **

```
💡변수의 이름은 어디에 등록되는가?
실행 컨텍스트
: 자바스크립트 엔진이 소스 코드를 평가하고 실행하기 위해 필요한 환경을 제공하고, 코드의 실행 결과를 실제로 관리하는 영역이다.
- 변수 이름과 변수 값은 실행 컨텍스트 내에 키 / 값 형식인 객체로 등록되어 관리된다.
```

## 변수 선언의 실행 시점과 변수 호이스팅

```
console.log(score); //undefined

var score; //변수 선언문
```

필자는 일반적인 코드 흐름에 따라 (인터프리터에 의해 한 줄 씩 순차적으로 실행되는 것)위 코드의 결과로 참조 에러가 발생할 것으로 예상했다.
하지만 결과는 `undefined`였고, 그 이유는 변수 선언의 실행 시점이 런타임(소스코드가 한 줄씩 순차적으로 실행되는 시점) 이전 단계에서 먼저 실행되기 때문이다.

런타임 이전에 자바스크립트가 하는 일은?

- 소스 코드의 평가 과정
: 변수 선언을 포함한 모든 선언문(변수 선언문, 함수 선언문 등)을 소스코드에서 찾아내 먼저 실행한다.
    - 이때 소스 코드의 아래쪽에 위치한 선언문들 역시 실행되는데 이를 **변수 호이스팅**이라고 한다. (끌어올려져 먼저 실행되는 것)
- 변수 호이스팅에 의해 선언문이 끌어올려지기 때문에 변수 선언이 소스 코드의 어디에 위치하는지와는 무관하게 어디서든 변수를 참조할 수 있다.

## 값의 할당

: 변수에 값을 할당할 때는 할당 연산자 (=)를 사용한다.

- 우변의 값을 좌변의 변수에 할당한다.

```
var score; //변수 선언
score = 90; //값의 할당

// 단축 표현
var score = 90;
```

위와 같이 단축 표현으로 변수를 선언하고 값을 할당할 수 있는데, 이때 주의할 점은 변수 선언과 값의 할당의 실행 시점이 다르다는 것이다.
-> 변수 선언은 호이스팅으로 런타임 이전에 실행되고, 값의 할당은 소스 코드가 순차적으로 실행되는 런타임에 실행된다.

## 값의 재할당
: 이미 값이 할당되어 있는 변수에 새로운 값을 또다시 할당하는 것을 말한다.

- > 기존에 사용하고 있던 주솟값에 있던 값을 지우고 새로 입력하는 것이 아닌, 새로운 메모리 공간에 재할당하고자하는 값을 넣고 주소값는 바꾸는 것이다.

| 주소값 | 값 |
| --- | --- |
| 0x00000 | undefined |
| 0x00001 | 80 |
| 0x00002 | 90 |

```
//런타임 이전에 score이 0x00000와 매핑되어 undefined로 초기화 됨
var score = 80; //변수 선언과 값의 할당_ score이 0x00001의 주소값과 매핑
score = 90; //값의 재할당_ score과 매핑된 주소값이 0x00002로 변경
```

- 더 이상 사용되지 않는 불필요한 값, 0x00000과 0x00001의 메모리 공간은 가비지콜렉터에 의해 메모리에서 자동 해제될 것이다.
- * 단, 메모리에서 언제 해제될 지는 예측할 수 없다. **
- const는 var, let키워드와는 다르게 변수에 값을 재할당할 수 없다.
    - 이를 재할당할 수 없는 변수, 상수라고 부른다.
- * 하지만, const키워드를 상수만을 위해 사용하지는 않는다. **

**추후 Link 예정**

## 식별자 네이밍 규칙

: 식별자는 다음과 같은 네이밍 규칙을 준수해야 한다.

- 식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(_), 달러 기호($)를 포함할 수 있다.
- 단, 식별자는 숫자 및 특수문자($ 제외)로 시작할 수 없다.
- 예약어는 식별자로 사용할 수 없다 (await, break, case, catch 등)

### 네이밍 컨벤션

: 하나 이상의 영어 단어로 구성된 식별자를 만들 때 가독성을 향상 시킬 수 있다.

```
//카멜 케이스 (camelCase)
var firstName;

//스네이크 케이스 (snake_case)
var first_name;

//파스칼 케이스 (PascalCase)
var FirstName;

//헝가리언 케이스(typeHungarianCase)
var strFirstName; // type + identifier
var $elem = document.getElementBuId("myId"); // DOM노드
var observable$ = fromEvent(document, 'click'); //RxJS 옵저버블
```

: 일관성을 유지한다면, 어떤 네이밍 컨벤션을 이용해도 좋지만 일반적인 사용법은 대략적으로 정해져 있다.

- 변수나 함수의 이름에는 카멜케이스
- 생성자 함수, 클래스 이름에는 파스칼케이스
