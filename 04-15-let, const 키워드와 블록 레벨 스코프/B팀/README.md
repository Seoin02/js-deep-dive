# 15장 lect, const 키워드와 블록 레벨 스코프

## 목차

1. [var 키워드로 선언한 변수의 문제점](#1-키워드로-선언한-변수의-문제점)
2. [let 키워드](#2-let-키워드)
3. [const 키워드](#3-const-키워드)
4. [var vs let vs const](#4-var-vs-let-vs-const)

<br />

## 1. var 키워드로 선언한 변수의 문제점

### 1-1. 변수 중복 선언 허용

- var 키워드의 경우, **재선언**을 할 수 있습니다. 예시를 통해, 이해해 보겠습니다.

```js
var x = 'global';
console.log(x); // global

var x = 'local';
console.log(x); // undefined
```

- 이처럼 같은 식별자였던 x를 다시 선언하고, 다른 값으로 할당 가능합니다. 

### 1-2. 함수 레벨 스코프

- var 키워드는 오로지 **함수 코드 블록만**을 지역 스코프로 인정합니다. (이는 실행 컨텍스트와도 밀접한 연관이 있습니다.)
- 따라서, 제어문 내부의 var 키워드는 개별적인 스코프를 가지지 못합니다.

### 1-3. 변수 호이스팅

- var 키워드는 실행 컨텍스트의 **평가** 단계에서, 선언과 초기화가 발생합니다. 이후, **실행** 단계를 거치게 됩니다. 따라서, 코드의 순서상 먼저 호출을 하더라도, 실행 문맥상 참조가 가능합니다. (단, undefined로 출력됩니다.)

<br />

## 2. let 키워드

### 2-1. 변수 중복 선언 금지

- let 키워드의 경우, **재선언**이 **불가능**합니다. 예시를 통해, 이해해 보겠습니다.

```js
let x = 'global';
console.log(x); // global

let x = 'local'; // Syntax error: x has already declared
```

- 이처럼 같은 식별자였던 x를 다시 선언할 수 없습니다.

- 물론, **재할당**은 가능합니다.

```js
let x = 'global';
console.log(x); // global

x = 'local';
console.log(x); // local
```

### 2-2. 블록 레벨 스코프

- let(그리고 const) 키워드는 모든 블록 레벨 스코프를 지역 스코프로 인정합니다.
- 따라서, 제어문 내부의 let 키워드는 개별적인 스코프를 가집니다.

### 2-3. 변수 호이스팅

- let 키워드는 실행 컨텍스트의 **평가** 단계에서, 선언이 발생하는 것은 동일합니다. 
- 그러나, var 키워드와 달리, **초기화**가 발생하지 않습니다. 이처럼, 선언 단계와 초기화 단계의 시간차에 의해, 변수를 참조할 수 없는 시간 구간을 **일시적 사각지대**라고 합니다.

```js
console.log(x); // ReferenceError: ~
let x = 'global';
```
- 분명한 건, let 키워드 역시, 선언이 먼저 발생합니다. 즉, **호이스팅이 발생합니다.** (호이스팅: 변수와 함수 선언이 해당 범위의 상단으로 끌어올려지는 동작. 즉, **선언이 우선되는 현상**)
- 다만, 일시적 사각지대에 의해, 구문 오류가 아닌 **참조 오류**를 발생시켜, 마치 호이스팅이 발생하지 않는 것처럼 보이게 합니다.

<br />

## 3. const 키워드

### 3-1. 선언과 초기화

- const 키워드의 경우, 반드시 **선언과 동시에 초기화**해야 합니다. 만약, 이를 분리할 경우, 구문 에러를 발생시킵니다.

```js
const x ; // Syntax error: Missing initializer in const declaration
```

### 3-2. 재할당 금지

- const 키워드는 **재할당 역시 금지**입니다.

### 3-3. 상수

- **상수**란 **재할당이 금지된 변수**를 의미합니다.
- 또한 상수는 스네이크 케이스로 표현하는 것이 일반적입니다.

### 3-4. const 키워드와 객체
- const 키워드로 선언한 변수에 **객체**를 할당할 경우, 값을 변경할 수 있습니다.
- **재할당**만 불가능할 뿐, 객체의 **불변을 의미하지는 않습니다.**

## 4. var vs let vs const
- var: 재선언, 재할당 가능
- let: 재할당 가능
- const: 모두 불가
- 공통: 변경 가능. 즉, 참조값를 변경할 수 있음.

- 결론만 정리하면, **웬만하면 const를 사용하라**라고 할 수 있겠습니다.