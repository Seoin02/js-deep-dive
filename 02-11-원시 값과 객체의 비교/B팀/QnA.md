1. 원시 타입과 객체 타입을 비교해주세요.(출처: 서인)
   > - 원시 타입: 변경 불가능한 값 / 값에 의한 전달 / 변수에 실제 값 저장
   > - 객체 타입: 프로퍼티 추가, 삭제 등 변경 가능한 값 / 참조에 의한 전달 / 변수에 참조 값 저장
2. 원시 값을 할당한 변수를 바꾸려면 어떤 과정을 거치나요
   > - 원시 값은 바꿀 수 없으므로 참조하는 메모리 주소를 변경하는 재할당을 해야 한다.
3. 객체가 변경 가능한 값으로 설계된 이유?(출처: 서인)
   > - 객체는 크기가 제각각이며, 복사해서 생성하는 비용이 많이 든다.
   > - 객체를 복사해 생성하는 비용을 절약해 성능을 향상시키고, 메모리를 효율적으로 사용하기 위해 객체는 변경 가능한 값으로 설계됐다.
4. 객체가 변경 가능하기 때문에 생기는 단점은?

   > - 여러 개의 식별자가 하나의 객체를 공유할 수 있다.
   > - 한 객체를 공유한 식별자는 같은 영향을 주고 받는다. 이는 한 식별자를 변경하면, 같은 객체를 공유한 다른 식별자에 삭제, 변경 등 의도치 않은 변경이 일어날 수 있다. 신뢰성이 떨어질 수 있다.

5. 해당 코드의 출력 결과와 이유를 설명해주세요.(출제: 아영)
   > - false, true
   > - 개체를 할당한 변수를 비교하면 참조 값을 비굑하고 원시값을 할당한 변수를 비교하면 원시 값을 비교합니다.

```jsx
const obj1 = { name: "lee" };
const obj2 = { name: "lee" };

console.log(obj1 === obj2);
console.log(obj1.name === obj2.name);
```

6. 객체의 얕은 복사와 깊은 복사의 차이는 무엇인가요?(출제: 보경)
   > - 얕은 복사는 1뎁스만 복사한다. 중첩된 객체의 모든 중첩 객체를 복사하지 않는다.
   > - 깊은 복사는 중첩된 객체의 모든 중첩 객체를 복사한다.
