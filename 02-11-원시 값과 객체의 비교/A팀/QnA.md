### 봉찬님 질문

Q : 원시 타입 값과 객체 타입의 값의 차이에 대해서 설명해 주세요.

- 지원 : 원시값은 변하지 않는 값이고 객체는 변할 수 있는 값
- 유경 : 원시 타입의 값은 불변성을 띄고, 객체 타입의 값은 변동될 수 있다.
- 은수 : 원시 타입 값: 불변합니다. 원시 타입의 값이 재할당 될 때는 ~~~ (뒷 내용은 봉찬님이 채워주실 겁니다.), 객체 타입 값: 가변합니다.

> 꼬리질문. 객체 타입의 값이 변동 될 수 있는 이유는 무엇인가요?

- 지원 : 동적으로 값을 변경해도 주소는 바뀌지 않아서
- 은수 : 객체를 선언할 경우, 객체를 담고 있는 메모리와, 객체를 담고 있는 메모리의 "주소"가 저장된 메로리가 할당됩니다. 그리고, 실행 컨택스트는 "주소값"을 참조하게 됩니다.메모리적 측면에서 객체를 새로 할당하는 것은 매우 불리합니다. <br /> 객체는 메모리 할당이 선언적으로 이뤄지지 않는 "용량"제한이 불분명한 대상이기 때문인데요.따라서, 메모리에 저장된 값 자체가 변경되는 것으로 구현된 것으로 보입니다...
- 유경 : 객체 타입의 변수에는 값이 들어있는 메모리의 주소가 직접적으로 들어가 있는 것이 아닌, 참조값이 들어있기 때문에 재할당 없이 값이 변경될 수 있습니다.

Q : 두 개의 식별자가 하나의 객체를 공유할 수 있는 이유에 대해서 설명해 주세요.

- 은수 : 객체는 객체 자체를 접근할 수 있는 메모리 주소를 참조값으로 선언한 식별자와 대응되기 때문에, 하나의 객체롤 공유할 수 있습니다.
- 유경 : 원시타입은 데이터를 복사해서 새로운 메모리에 재할당하는데, 객체는 기존의 메모리 공간을 재할당하지 않고 변경이 가능해 다른 변수에 객체를 할당하더라도 같은 객체를 가리키는 참조값을 공유하게 됩니다.
- 지원 : 원본과 사본은 가리키는 메모리 주소는 다르지만 같은 참조값을 갖기 때문
- 봉찬 : 객체를 담는 변수는 객체가 저장된 메모리 주소(참조 값)을 가진다. 동일한 참조 값을 가지는 식별자가 존재한다면(얕은 복사) 하나의 객체를 서로 공유하게 된다.

---

### 유경님 질문

Q : 원시 타입과 객체 타입의 차이점을 변수 선언, 할당, 재할당 과정을 근거로 설명해주세요.

- 봉찬 : 원시 타입을 담는 변수를 선언할 때 이미 원시 타입이 존재하면 해당 원시 타입의 메모리 주소를 참조하게 됩니다. 재할당 과정에서는 원시 값이 저장된 메모리 공간을 변경하는 것이 아닌 새로운 메모리 공간을 확보 후에 원시 값을 넣고 식별자가 지닌 원시 값의 메모리 주소를 변경합니다.
- 은수 : <br/> 1. 변수 선언적 관점: 변수가 선언될 경우, 메모리안에는 값이 저장됩니다. 실행 컨텍스트(혹은 전역 객체 ? )는 값을 저장하는 주소값을 참조합니다./ 반면 객체는 객체를 담고 있는 메모리 -> 해당 메모리 주소를 가리키는 메모리 -> 주소를 카리키는 메모리를 참조하는 구조로 작성됩니다. <br/>2. 할당: 할당의 경우는 위에 이미 언급했듯, 메모리 안에 저장되냐, 새로운 메모리에 저장되고, 해당 메모리 주소를 가리키는 메모리를 다시 할당하는 것으로 구분되네요.<br/>3. 재할당: 새로운 값을 다시 생성합니다. 참조값은 변화하지 않고, 새로운 메모리 공간에 같은 참조값(객체를 가리키는)을 가지게 됩니다.

Q : 객체 타입의 구조적 부작용과 그를 해결하는 방법을 설명해주세요.

- 봉찬 : 객체에는 모든 값을 담을 수 있기 때문에 객체를 담은 변수를 다른 변수에 할당할 때 원시 값과 같은 복사(깊은 복사)가 되는 것이 아니라 얕은 복사가 이루어질 수 있습니다. 내부에 참조 타입 값이 존재하는 지 확인해서 깊은 복사를 구행할 수 있고 대표적인 라이브러리로 lodash가 있습니다.
- 은수 : 객체 타입의 구조적 부작용: 참조값을 따로 할당하는 구조다 보니, 여러 곳에서 하나의 객체를 접근하고 변경할 수 있습니다. 따라서, 객체 자체를 복사하는 방법으로? 문제를 해결합니다.

### 은수님 질문

Q : 객체는 어디에 저장될까요?

- 봉찬 : 스택
- 지원 : 힙
- 은수 : 원시값 : 실행 컨택스트 (스택)
  객체 : 렉시컬 환경 -> 렉시컬 환경 컴포넌트 -> 환경 레코드 -> 객체 환경 레코드 (힙)
